import math
import shutil

import pytest
from agr_literature_service.api.models import (
    ReferencetypeModel,
    ModReferencetypeAssociationModel,
    ModModel,
    initialize,
    drop_open_db_sessions)
from agr_literature_service.api.database.base import Base
from agr_literature_service.api.database.config import SQLALCHEMY_DATABASE_URL
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from os import environ, path

from agr_literature_service.lit_processing.data_ingest.post_reference_to_db import post_references
from agr_literature_service.lit_processing.tests.mod_populate_load import populate_test_mods
from agr_literature_service.api.config import config


def delete_all_table_content(engine):
    if environ.get('TEST_CLEANUP') == "true":
        # for table in ['author']:
        #    print(f"Stop triggers for {table}")
        #    engine.execute(f"ALTER TABLE {table} DISABLE TRIGGER ALL;")

        print("***** Deleting test data from all tables *****")
        for table in reversed(Base.metadata.sorted_tables):
            # print(f"***** Deleting table {table.fullname}")
            if table.fullname != "users":
                engine.execute(table.delete())
        # for table in ['author']:
        #    print(f"Start trigger for {table}")
        #    engine.execute(f"ALTER TABLE {table} ENABLE TRIGGER ALL;")


@pytest.fixture
def db() -> Session:
    print("***** Creating DB session *****")
    if ("rds.amazonaws.com" in config.PSQL_HOST):
        msg = "***** Warning: not allow to run test on stage or prod database *****"
        pytest.exit(msg)
    else:
        engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"options": "-c timezone=utc"})
        initialize()
        delete_all_table_content(engine)
        db = sessionmaker(bind=engine, autoflush=True)()
        yield db
        delete_all_table_content(engine)
        drop_open_db_sessions(db)
        print("***** Closing DB session *****")
        db.close()


@pytest.fixture
def cleanup_tmp_files_when_done():
    """
    Deletes temp files generated by scripts under XML_PATH

    The cleanup is happening when the test importing this fixture exits, not when it is called
    """
    yield None
    if environ.get('TEST_CLEANUP') == "true":
        base_path = environ.get('XML_PATH')
        shutil.rmtree(base_path)


@pytest.fixture
def populate_test_mod_reference_types(db):
    populate_test_mods()
    mod_reference_types = {'ZFIN': ['Journal', 'Review'], 'FB': ['book'], 'WB': ['Journal_article', 'Micropublication'],
                           'SGD': ['Journal']}
    for mod, reference_types in mod_reference_types.items():
        mod = db.query(ModModel).filter(ModModel.abbreviation == mod).one()
        display_order = 10
        for reference_type in reference_types:
            rt_obj = db.query(ReferencetypeModel).filter(ReferencetypeModel.label == reference_type).one_or_none()
            if rt_obj is None:
                rt_obj = ReferencetypeModel(label=reference_type)
                db.add(rt_obj)
            mod_reference_type_obj = ModReferencetypeAssociationModel(mod=mod, referencetype=rt_obj,
                                                                      display_order=display_order)
            db.add(mod_reference_type_obj)
            display_order = math.ceil((display_order + 1) / 10) * 10
    db.commit()


@pytest.fixture
def load_sanitized_references(populate_test_mod_reference_types):
    json_file_path = path.join(path.dirname(path.abspath(__file__)), "lit_processing", "sample_data",
                               "sanitized_references/")
    post_references(json_path=json_file_path)
    yield None


def get_descendants_mock(name):
    # MUST start with ATP:0000003 for this to work
    print(f"***** Mocking get_ancestors name = {name}")
    if name == 'ATP:0000177':
        return ['ATP:0000172', 'ATP:0000140', 'ATP:0000165', 'ATP:0000161']
    elif name == 'ATP:0000172':
        return ['ATP:0000175', 'ATP:0000174', 'ATP:0000173', 'ATP:0000178']
    elif name == 'ATP:0000140':
        return ['ATP:0000141', 'ATP:0000135', 'ATP:0000139', 'ATP:0000134']
    elif name == 'ATP:0000165':
        return ['ATP:0000168', 'ATP:0000167', 'ATP:0000170', 'ATP:0000171', 'ATP:0000169', 'ATP:0000166']
    elif name == 'ATP:0000161':
        return ['ATP:0000164', 'ATP:0000163', 'ATP:0000162']
    else:
        print("returning NOTHING!!")
        return []