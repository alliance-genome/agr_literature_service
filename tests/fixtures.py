import math
import shutil

import pytest
from agr_literature_service.api.models import initialize, ReferenceTypeModel, ModReferenceTypeAssociationModel, ModModel
from agr_literature_service.api.database.base import Base
from agr_literature_service.api.database.config import SQLALCHEMY_DATABASE_URL
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from os import environ, path

from agr_literature_service.lit_processing.data_ingest.post_reference_to_db import post_references
from agr_literature_service.lit_processing.tests.mod_populate_load import populate_test_mods


def delete_all_table_content(engine):
    if environ.get('TEST_CLEANUP') == "true":
        print("***** Deleting test data from all tables *****")
        for table in reversed(Base.metadata.sorted_tables):
            if table.fullname != "users":
                engine.execute(table.delete())


@pytest.fixture
def db() -> Session:
    print("***** Creating DB session *****")
    engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"options": "-c timezone=utc"})
    initialize()
    delete_all_table_content(engine)
    db = sessionmaker(bind=engine, autoflush=True)()
    yield db
    delete_all_table_content(engine)
    print("***** Closing DB session *****")
    db.close()


@pytest.fixture
def cleanup_tmp_files_when_done():
    """
    Deletes temp files generated by scripts under XML_PATH

    The cleanup is happening when the test importing this fixture exits, not when it is called
    """
    yield None
    if environ.get('TEST_CLEANUP') == "true":
        base_path = environ.get('XML_PATH')
        shutil.rmtree(base_path)


@pytest.fixture
def populate_test_mod_reference_types(db):
    populate_test_mods()
    mod_reference_types = {'ZFIN': ['Journal', 'Review'], 'FB': ['book'], 'WB': ['Journal_article', 'Micropublication'],
                           'SGD': ['Journal']}
    for mod, reference_types in mod_reference_types.items():
        mod = db.query(ModModel).filter(ModModel.abbreviation == mod).one()
        display_order = 10
        for reference_type in reference_types:
            rt_obj = db.query(ReferenceTypeModel).filter(ReferenceTypeModel.label == reference_type).one_or_none()
            if rt_obj is None:
                rt_obj = ReferenceTypeModel(label=reference_type)
                db.add(rt_obj)
            mod_reference_type_obj = ModReferenceTypeAssociationModel(mod=mod, referencetype=rt_obj,
                                                                      display_order=display_order)
            db.add(mod_reference_type_obj)
            display_order = math.ceil(display_order / 10) * 10
    db.commit()


@pytest.fixture
def load_sanitized_references(populate_test_mod_reference_types):
    json_file_path = path.join(path.dirname(path.abspath(__file__)), "lit_processing", "sample_data",
                               "sanitized_references/")
    post_references(json_path=json_file_path)
    yield None
