# generated by AI
from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Optional

import pytest
from sqlalchemy import Column, Integer, String, inspect

from agr_literature_service.api.database.base import Base
from agr_literature_service.api.models.audited_model import AuditedModel
from agr_literature_service.api.models.user_model import UserModel
from agr_literature_service.api.user import set_global_user_id

from ..fixtures import db  # noqa: F401


# ----------------------------- helpers -----------------------------

class AuditedDummy(Base, AuditedModel):
    __tablename__ = "audited_dummy"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)


def _utc_now() -> datetime:
    return datetime.now(timezone.utc)


def _to_utc(dt: datetime) -> datetime:
    # normalize both aware/naive to aware UTC for comparisons
    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)


def _is_recent(dt: datetime, seconds: int = 5) -> bool:
    return abs((_to_utc(_utc_now()) - _to_utc(dt)).total_seconds()) < seconds


def _ensure_user(db, uid: Optional[str]):  # noqa
    if not uid:
        return
    if not db.query(UserModel).filter_by(id=uid).one_or_none():
        db.add(UserModel(id=uid))
        db.commit()


# ----------------------------- fixtures -----------------------------

@pytest.fixture(autouse=True)
def _reset_user_ctx():
    """Ensure each test starts/ends with no global user set."""
    try:
        set_global_user_id(None)
    except TypeError:
        # Older signatures: best-effort clear
        set_global_user_id("")  # type: ignore
    yield
    try:
        set_global_user_id(None)
    except TypeError:
        set_global_user_id("")  # type: ignore


@pytest.fixture(autouse=True)
def _create_tables(db):  # noqa
    """Create table once per test function; ensure FK targets exist."""
    engine = db.get_bind()
    insp = inspect(engine)
    if not insp.has_table(AuditedDummy.__tablename__):
        Base.metadata.create_all(bind=engine, tables=[AuditedDummy.__table__])

    # Make sure FK targets exist
    for uid in ("default_user", "OTTO", "MANUAL_CREATOR"):
        _ensure_user(db, uid)

    yield

    # Clean up rows for isolation
    db.query(AuditedDummy).delete()
    db.commit()


# ------------------------------ tests ------------------------------

def test_insert_autostamps_when_no_global_user(db):  # noqa
    """Insert with no fields set -> stamps dates and default user; date_updated mirrors date_created."""
    obj = AuditedDummy(name="alpha")
    db.add(obj)
    db.commit()
    db.refresh(obj)

    assert isinstance(obj.date_created, datetime)
    assert isinstance(obj.date_updated, datetime)
    assert _is_recent(obj.date_created)
    assert _is_recent(obj.date_updated)
    assert obj.date_updated == obj.date_created  # mirror on insert
    assert obj.created_by == "default_user"
    assert obj.updated_by == "default_user"


def test_insert_respects_explicit_created_fields_and_mirrors_updated(db):  # noqa
    """
    On INSERT:
      - keep provided date_created/created_by
      - date_updated mirrors date_created
      - updated_by mirrors created_by
    """
    manual_created = _utc_now() - timedelta(days=10)
    _ensure_user(db, "MANUAL_CREATOR")

    obj = AuditedDummy(
        name="bravo",
        date_created=manual_created,
        created_by="MANUAL_CREATOR",
    )
    db.add(obj)
    db.commit()
    db.refresh(obj)

    assert _to_utc(obj.date_created) == _to_utc(manual_created)
    assert obj.created_by == "MANUAL_CREATOR"
    assert obj.date_updated == obj.date_created
    assert obj.updated_by == "MANUAL_CREATOR"


def test_first_update_after_insert_is_skipped(db):  # noqa
    """
    The very first UPDATE after INSERT should NOT stamp audit fields.
    """
    obj = AuditedDummy(name="charlie")
    db.add(obj)
    db.commit()
    db.refresh(obj)

    created_dc = obj.date_created
    created_du = obj.date_updated
    created_cb = obj.created_by
    created_ub = obj.updated_by

    # First update (post-insert normalization in real flows) -> skipped
    obj.name = "charlie-2"
    db.add(obj)
    db.commit()
    db.refresh(obj)

    assert obj.date_created == created_dc
    assert obj.date_updated == created_du  # unchanged
    assert obj.created_by == created_cb
    assert obj.updated_by == created_ub    # unchanged


def test_later_update_stamps_now_and_global_user(db):  # noqa
    """
    After the first post-insert update is consumed, subsequent UPDATEs:
      - set date_updated := now (UTC)
      - set updated_by   := current user (or default)
    """
    obj = AuditedDummy(name="delta")
    db.add(obj)
    db.commit()
    db.refresh(obj)

    # Consume the skip by doing one no-op business update
    obj.name = "delta-2"
    db.add(obj)
    db.commit()
    db.refresh(obj)

    prev_updated = obj.date_updated

    # Now set a request user and perform a real update
    _ensure_user(db, "OTTO")
    set_global_user_id("OTTO")

    obj.name = "delta-3"
    db.add(obj)
    db.commit()
    db.refresh(obj)

    assert obj.updated_by == "OTTO"
    assert obj.date_updated >= prev_updated
    assert _is_recent(obj.date_updated)


def test_later_update_uses_default_user_when_global_unset(db):  # noqa
    """
    If no request user is set, later UPDATEs stamp updated_by as 'default_user'.
    """
    obj = AuditedDummy(name="echo")
    db.add(obj)
    db.commit()
    db.refresh(obj)

    # Consume the skip flag
    obj.name = "echo-2"
    db.add(obj)
    db.commit()
    db.refresh(obj)

    prev_updated = obj.date_updated

    # No global user now
    set_global_user_id(None)

    obj.name = "echo-3"
    db.add(obj)
    db.commit()
    db.refresh(obj)

    assert obj.updated_by == "default_user"
    assert obj.date_updated >= prev_updated
    assert _is_recent(obj.date_updated)
